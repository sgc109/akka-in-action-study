# 내고장성

* 내고장성이 있는 시스템이 되기 위해서는 특정 부분에 문제가 발생하더라도 이것이 전체 시스템에 영향을 끼치지 않고 잘 격리되어 전체 시스템은 잘 동작해야 하고, 대체 수단이 있어서 가용성을 유지해야 하며, 적절한 복구가 가능해야한다.
* 절차지향에서는 매 행마다 예외처리를 해야했다.
* 객체지향에서는 Exception 과 try-catch 문을 사용하여 여러 행을 하나로 묶어 예외처리를 할 수 있게 되었고, 편리하게 함수의 호출 스택을 추적할 수 있게 되었으나, 지금까지 크게 발전하지는 않았다.
* 객체지향에서 예외 처리(고장 복구)를 할 때의 문제는 다음과 같다.
  * 일반 로직과 예외 처리 로직, 혹은 복구 로직이 분리되지 않고 한데 섞여있다는 것
  * 의존관계의 상단부에서는 하단부에서 발생한 예외에 관한 정보가 부족하여 적절히 대처하기 힘들다.
  * 물론 예외 관련 정보를 상단부까지 공유할 수도 있으나, 이것은 캡슐화, 제어의 역전(IoC), 단일 책임 원칙(SRP) 등에 위배되는 행위다.
  * 특정 컴포넌트가 복구되는 동안 들어온 요청을 복구된 이후에 사용해야할 수도 있기 때문에 버퍼에 저장해두었다가 사용하는 기능을 직접 구현해야한다.
  * 일반적인 프로그램은 객체에 직접 접근하여 사용하기 때문에 특정 컴포넌트의 복구가 진행되는 동안 다른 스레드가 고장난 컴포넌트를 사용하지 않도록 예외를 스레드 사이에서 전달하는 기능을 직접 구현해야한다.(당연한거지만, 각 스레드는 별도의 스택을 가지므로 특정 예외가 콜스택을 따라 전파되지 않는다)
* 아카는
  * 특정 액터에 문제가 생긴 동안 들어온 메시지가 메일 박스에 쌓이고 있으며
  * 복구 로직은 supervisor 가 담당하므로 일반 로직과 복구 로직이 분리되며, 참조 계층 관계 상 상단부의 액터에 영향을 퍼뜨리지 않는다.
  * 액터는 ActorRef 를 통해 간접참조를 하기 때문에 문제 발생 전과 복구 이후에 모두 같은 ActorRef 를 사용하기 떄문에 복구가 간편하다.
  * 그래서 고장 격리, 재시작, 복구 등이 매우 단순해져 내고장성이 있는 시스템을 만드는것이 간단하다.

## 복구
* 아카는 let-it-crash 원칙을 사용한다.
* 특정 액터에서 문제가 발생하면 일단 중단되게 내버려두고 나서
* supervisor(자신을 생성한 액터) 가 다음 4가지 중 하나를 선택한다.
    * 재시작(restart)
    * 계속 진행(resume)
    * 종료(stop)
    * 위로 전달(escalate)
* 액터는 생명주기가 있어 복구를 쉽게한다


## 콜백 함수
* 시작
    * constructor -> preStart()
* 종료
    * postStop()
* 재시작
    * preRestart()(내부적으로 postStop() 도)-> constructor -> postRestart()(내부적으로 preStart() 도)

* 액터를 종료하는 방법은 ActorSystem.stop() 나 ActorContext.stop() 나 PoisonPill 을 보내는 방법이 있다.
* PoisonPill 을 받으면 내부적으로 stop() 호출한다.
* self 는 자기 자신의 ActorRef 다.
* self ! PoisonPill 로 자기를 종료시킬 수 있다.
* 종료된 액터의 ActorRef 는 deadLetterActorRef 가 되어, 죽은 액터에게 보내진 메시지를 모두 받는다
* preRestart 와 postRestart 는 super 를 호출해야하는데, 각각 내부적으로 postStop 과 preStart 를 호출하며
* preRestart 는 내부적으로 자식들을 모두 stop 한다.

## 감시
* 부모 액터만 할 수 있는 '감독'과는 달리 ActorRef 만 알면 '감시(watch)' 할 수 있다.
* 감시하는 액터가 종료되면 Terminated 메시지를 받는다.
* stop 으로 종료되지 않고 갑자기 중단되는 경우에는 받지 못한다.

## 계층 구조
* 특정 액터가 다른 액터를 생성하면 자동으로 계층 구조가 생기며, 부모 액터가 supervisor 가 된다.
* 한 번 구축된 부모-자식 관계는 부모가 자식을 종료시키지 않는이상 절대 변경되지 않는다.
* 애플리케이션의 최상위 액터는 /user 경로(akka://actorSystem/user)에 만들어지며 **user guardian**에 의해 감독된다.
* 중단될 가능성이 큰 액터는 계층 구조상 아래쪽에 있어야 한다.
* 그래야 많은 슈퍼바이저에 의해 처리될 수 있다.
* 상단에 있을 경우 운이 좋지 않으면 액터 시스템이 종료된다.
* Exception 이 아닌, ThreadDeath 나 OOM 같은 Error 는 어차피 복구하기가 거의 불가능하므로 슈퍼바이저에서 처리하지 않는게 좋다.
* 그럼 유저 가디언까지 올라가서 액터 시스템을 종료하는데 이렇게 두는것이 낫다.

## 감독
* 액터의 디폴트 감독 전략은 SupervisorStrategy.defaultStrategy 이며, 내부 이유로 종료되거나 초기화 도중 실패하는 경우엔 해당 액터를 종료하며, 그 외에는 자식을 재시작하는 전략이다.
* SupervisorStrategy.stoppingStrategy 도 있는데 모든 실패하는 자식들을 종료시킨다.
* supervisorStrategy 를 오버라이드하여 supervisor 액터의 기본 감독 전략을 변경할 수 있다.
* supervisorStrategy 는 감독 대상 액터가 중단되었을 때 4가지(Restart, Stop, Resume, Escalate) 중 어떤 선택을 할 지만 정하는 것이고, 액터가 종료되었을 때 실행되는 로직을 정의하기 위해서는 감시(context.watch())를 하여 receive() 에서 Terminate 메시지를 처리해야 한다.
